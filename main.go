package main

import (
	"flag"
	"fmt"
	"log"

	"github.com/florianherrengt/hubhook/config"
	_ "github.com/florianherrengt/hubhook/docs" // docs is generated by Swag CLI, you have to import it.

	"github.com/jinzhu/configor"
)

func main() {
	err := configor.Load(&config.Config, "config.yml")
	if err != nil {
		log.Fatal(err)
	}

	startAPI := flag.Bool("api", false, "turn on the api")
	startDBWorker := flag.Bool("db-worker", false, "turn on the api")
	flag.Parse()

	fmt.Println(*startAPI, *startDBWorker)

	// wg := sync.WaitGroup{}
	// opts := []nats.Option{nats.Name("NATS Sample Queue Subscriber")}
	// opts = setupConnOptions(opts)
	// nc, err := nats.Connect(nats.DefaultURL, opts...)
	// sc, err := stan.Connect("test-cluster", "whatever")
	// if err != nil {
	// 	log.Panicln(err)
	// }
	// defer sc.Close()

	// if err != nil {
	// 	log.Fatal(err)
	// }
	// defer nc.Close()
	// aw, _ := time.ParseDuration("60s")

	// qsub, err := sc.QueueSubscribe("subj",
	// 	"queue", func(m *stan.Msg) {
	// 		fmt.Println("1", string(m.Data))
	// 		err := m.Ack()
	// 		if err != nil {
	// 			log.Fatalln(err)
	// 		}
	// 	}, stan.DurableName("hello"), stan.MaxInflight(1),
	// 	stan.DeliverAllAvailable(), stan.SetManualAckMode(), stan.AckWait(aw))

	// defer qsub.Unsubscribe()

	// _, err = sc.QueueSubscribe("subj",
	// 	"queue", func(m *stan.Msg) {
	// 		fmt.Println("2", string(m.Data))
	// 		err := m.Ack()
	// 		if err != nil {
	// 			log.Fatalln(err)
	// 		}
	// 	}, stan.DurableName("hello"), stan.DeliverAllAvailable(), stan.SetManualAckMode(), stan.AckWait(aw))

	// _, err = nc.Request("subj", []byte("this is a test"), time.Second*2)
	// fmt.Println(err)
	// sc.Publish("subj", []byte("this is a test"))
	// sc.Publish("subj", []byte("this is a second test"))
	// sc.Publish("subj", []byte("this is a thrif test"))
	// nc.Publish("subj", []byte("this is a test"))

	// nc.Flush()

	// models.ConnectDataBase()
	// r := gin.New()

	// use ginSwagger middleware to serve the API docs
	// r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// r.GET("/accounts/:id", controller.ShowAccount)
	// r.POST("/event", controller.CreateEvent)
	// r.DELETE("/events", controller.DeleteAllEvents)
	// r.GET("/events", controller.ListEvents)
	// r.Run(":" + os.Getenv("PORT"))

	// c := make(chan os.Signal, 1)
	// signal.Notify(c, os.Interrupt)
	// <-c
	// log.Println()
	// log.Printf("Draining...")
	// nc.Drain()
	// log.Fatalf("Exiting")

	// wg.Add(1)
	// wg.Wait()
}

// func setupConnOptions(opts []nats.Option) []nats.Option {
// 	totalWait := 10 * time.Minute
// 	reconnectDelay := time.Second

// 	opts = append(opts, nats.ReconnectWait(reconnectDelay))
// 	opts = append(opts, nats.MaxReconnects(int(totalWait/reconnectDelay)))
// 	opts = append(opts, nats.DisconnectErrHandler(func(nc *nats.Conn, err error) {
// 		log.Printf("Disconnected due to: %s, will attempt reconnects for %.0fm", err, totalWait.Minutes())
// 	}))
// 	opts = append(opts, nats.ReconnectHandler(func(nc *nats.Conn) {
// 		log.Printf("Reconnected [%s]", nc.ConnectedUrl())
// 	}))
// 	opts = append(opts, nats.ClosedHandler(func(nc *nats.Conn) {
// 		log.Fatalf("Exiting: %v", nc.LastError())
// 	}))
// 	return opts
// }
